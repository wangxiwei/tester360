<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Language" content="en-us" />

		<title>Django | 编写自定义的 model 字段(Writing custom model fields) | Django 文档</title>

		<meta name="ROBOTS" content="ALL" />
		<meta http-equiv="imagetoolbar" content="no" />
		<meta name="MSSmartTagsPreventParsing" content="true" />
		<meta name="Copyright" content="This site's design and contents Copyright (c) 2005  Lawrence Journal-World." />

		<meta name="keywords" content="Python, Django, framework, open-source" />
		<meta name="description" content="Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design." />

		<link href="http://media.djangoproject.com/css/base.css" rel="stylesheet" type="text/css" media="screen" />
		<link href="http://media.djangoproject.com/css/print.css" rel="stylesheet" type="text/css" media="print" />
      
  
  <style type="text/css" media="screen">
    #docs-search {
      color: #000;
      float: right;
    }
    #docs-search form {
      font-size: 92%;
      margin: 0;
      padding: 1em 1em 0;
      white-space: nowrap;
    }
    form.search ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    form.search li {
      display: inline;
      padding-right: 1em;
    }
    form.search .query {
      width: 18em;
    }
  </style>
  <link rel="stylesheet" href="http://media.djangoproject.com/css/pygments.css" type="text/css" />

	<!-- tester360.cn Baidu tongji analytics -->
<script>
var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?7d789811683659f2ce2723c13b6f88ef";
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();
</script>
</head>

	<body id="documentation" class="default">

	<div id="container">
		<div id="header">
			<h1 id="logo"><a href="http://www.djangoproject.com/"><img src="http://media.djangoproject.com/img/site/hdr_logo.gif" alt="Django" /></a></h1>
			<ul id="nav-global">
				<li id="nav-homepage"><a href="http://www.djangoproject.com/">Home</a></li>
				<li id="nav-download"><a href="http://www.djangoproject.com/download/">Download</a></li>
				<li id="nav-documentation"><a href="http://docs.djangoproject.com/">Documentation</a></li>
				<li id="nav-weblog"><a href="http://www.djangoproject.com/weblog/">Weblog</a></li>
				<li id="nav-community"><a href="http://www.djangoproject.com/community/">Community</a></li>
				<li id="nav-code"><a href="http://code.djangoproject.com/">Code</a></li>
			</ul>
		</div>
		<!-- END Header -->
		<div id="billboard">
  <h2><a href="../../index.html">Django documentation</a></h2>
</div>
		<div id="columnwrap">
			
		<div id="content-main">
		


  <h2 class="deck">
  
    当前文档仅适用于 Django SVN 版本，与上个版本有显著不同。上个版本文档请查阅
      <a href="http://docs.djangoproject.com/en/1.0/howto/custom-model-fields/">Django 1.0</a>
  
  </h2>
  <div class="section" id="s-writing-custom-model-fields">
<span id="s-howto-custom-model-fields"></span><span id="writing-custom-model-fields"></span><span id="howto-custom-model-fields"></span><h1>编写自定义 model 字段(Writing custom model fields)<a class="headerlink" href="index.html#writing-custom-model-fields" title="Permalink to this headline">¶</a></h1>
<div class="versionadded">
<span class="title">这部分是在 Django 1.0 新增的：</span> <a class="reference external" href="../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<div class="section" id="s-introduction">
<span id="introduction"></span><h2>介绍(Introduction)<a class="headerlink" href="index.html#introduction" title="Permalink to this headline">¶</a></h2>
<p> <a class="reference external" href="../../topics/db/models/index.html#topics-db-models"><em>model 参考(model reference)</em></a> 文档已经介绍了如何使用 Django 的标准字段类；例如 <a title="django.db.models.CharField" class="reference external" href="../../ref/models/fields/index.html#django.db.models.CharField"><tt class="xref docutils literal"><span class="pre">CharField</span></tt></a>，
<a title="django.db.models.DateField" class="reference external" href="../../ref/models/fields/index.html#django.db.models.DateField"><tt class="xref docutils literal"><span class="pre">DateField</span></tt></a>，等等。对于很多应用来说，这些类足够用了。但是在某些情况下， 你所用的Django 版本不提供你想要的某些功能，或是你想使用的字段与 Django 自带字段不同。</p>
<p>Django 内置的字段类型并不能覆盖所有可能遇到的数据库的列类型，仅仅是些普通的字段类型，例如 <tt class="docutils literal"><span class="pre">VARCHAR</span></tt> 和 <tt class="docutils literal"><span class="pre">INTEGER</span></tt>。对于更多不常用的列类型，比如地理定位数据和诸如 <a class="reference external" href="http://www.postgresql.org/docs/8.2/interactive/sql-createtype.html">PostgreSQL custom types</a> 的自定义字段，你可以定义你自己的Django <tt class="docutils literal"><span class="pre">Field</span></tt> 子类。</p>
<p>有两种实现方式：你可以编写一个复杂的 Python 对象，让它以某种方式将数据序列化，以适应某个数据库的列类型；或是你创建一个 <tt class="docutils literal"><span class="pre">Field</span></tt> 子类，从而让你可以使用 model 中的对象。</p>
<div class="section" id="s-our-example-object">
<span id="our-example-object"></span><h3>示例对象(Our example object)<a class="headerlink" href="index.html#our-example-object" title="Permalink to this headline">¶</a></h3>
<p>创建自定义字段需要注意很多细节。为了使这一章内容容易理解，自始至终我们都只使用这一个例子：包装一个 Python 对象来表示手中桥牌的详细信息。不用担心，这个例子并不要求你会玩桥牌。你只要知道 52 张牌被分配个四个玩家，按惯例，他们被称之为<b>北(north)</b>, <b>东(east)</b>, <b>南(south)</b> 和 <b>西(west)</b>。我们的类看起来就象这个样子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Hand</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">):</span>
        <span class="c"># Input parameters are lists of cards (&#39;Ah&#39;, &#39;9s&#39;, etc)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">north</span> <span class="o">=</span> <span class="n">north</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">east</span> <span class="o">=</span> <span class="n">east</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">south</span> <span class="o">=</span> <span class="n">south</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">west</span> <span class="o">=</span> <span class="n">west</span>

    <span class="c"># ... (other possibly useful methods omitted) ...</span>
</pre></div>
</div>
<p>这只是一个普通的 Python 类，并没有对 Django 做特别的设定。在 model 中我们可以象下面这样使用 Hand (我们假设 model 中的
<tt class="docutils literal"><span class="pre">hand</span></tt> 属性是 <tt class="docutils literal"><span class="pre">Hand</span></tt> 类的一个实例)：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">example</span> <span class="o">=</span> <span class="n">MyModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
<span class="k">print</span> <span class="n">example</span><span class="o">.</span><span class="n">hand</span><span class="o">.</span><span class="n">north</span>

<span class="n">new_hand</span> <span class="o">=</span> <span class="n">Hand</span><span class="p">(</span><span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">hand</span> <span class="o">=</span> <span class="n">new_hand</span>
<span class="n">example</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>我们可以象使用任何 Python 类一样，对 model 中的 <tt class="docutils literal"><span class="pre">hand</span></tt> 属性进行赋值和取值。利用这一点让 Django 知道如何处理保存和载入一个对象。</p>
<p>为了在 model 中使用 <tt class="docutils literal"><span class="pre">Hand</span></tt> 类，我们不必为这个类做任何的改动。这是非常有用的，它表示着你可以很容易地为已存在的类编写 model 支持，而不必改动类的原代码。</p>
<div class="admonition note">
<p class="first admonition-title">注意</p>
<p class="last">你可能只想利用自定义数据库列类型，将数据处理成 model 中的标准 Python 类型，比如：字符串，浮点数等等。这种情况与我们的 <tt class="docutils literal"><span class="pre">Hand</span></tt> 例子非常相似，我们随着文档的展开对两者的差异进行比较。</p>
</div>
</div>
</div>
<div class="section" id="s-background-theory">
<span id="background-theory"></span><h2>后台原理(Background theory)<a class="headerlink" href="index.html#background-theory" title="Permalink to this headline">¶</a></h2>
<div class="section" id="s-database-storage">
<span id="database-storage"></span><h3>数据库存储(Database storage)<a class="headerlink" href="index.html#database-storage" title="Permalink to this headline">¶</a></h3>
<p>可以简单的认为 model 字段提供了一种方法来接受普通的 Python 对象，比如布尔值，时间 <tt class="docutils literal"><span class="pre">datetime</span></tt>，或是象 <tt class="docutils literal"><span class="pre">Hand</span></tt> 这样更复杂的对象，然后在操作数据库时，对对象进行格式转换以适应数据库。（还有序列化也是同杰处理，但接下来我们会看到，一旦我们掌握了数据库这方面的转换，再对序列化做处理就游刃有余了）</p>
<p>为了让 model 字段适应数据库列类型，必须对字段进行某种形式的转换。虽然不同的数据库提供了不同的列类型，但是有一条准则不是变的：你只能使用数据库本身提供的这些字段。任何你想存储在数据库的信息必须适用于这些字段中的某一个。</p>
<p>通常情况下，你可以编写一个字段，让它匹配数据库的某个列类型；也可以用一种简单而直接方法对数据进行转换，比如说，转换成字符串。</p>
<p>对于我们的 <tt class="docutils literal"><span class="pre">Hand</span></tt> 例子，我们可以将纸牌数据转换成长度为104的字符串。转换方法是按出牌顺序，将纸牌编号连在一起，也就是说，先是所有的<b>北(north)</b>牌手的牌，再是<b>东(east)</b>，然后是<b>南(south)</b>，最后是<b>西(west)</b>。因为 <tt class="docutils literal"><span class="pre">Hand</span></tt> 对象可以保存在数据库中的文本或是字符字段中。</p>
</div>
<div class="section" id="s-what-does-a-field-class-do">
<span id="what-does-a-field-class-do"></span><h3>字段类做了哪些工作(What does a field class do?)<a class="headerlink" href="index.html#what-does-a-field-class-do" title="Permalink to this headline">¶</a></h3>
<p>所有的 Django 字段fields (我们在这篇文档中谈到的 <b><em>字段(fields)</em></b> 指的都是 model 字段而不是 <a class="reference external" href="../../ref/forms/fields/index.html#ref-forms-fields"><em>表单字段(form fields)</em></a>) 都是继承自 <tt class="xref docutils literal"><span class="pre">django.db.models.Field</span></tt>。 所有字段的大部分信息都是相同的，例如 -- name, help text, uniqueness 等等。这部分信息都是由 <tt class="docutils literal"><span class="pre">Field</span></tt> 类处理的，后面我们会深入谈到 <tt class="docutils literal"><span class="pre">Field</span></tt> 是怎么做到这一点的；现在，只要知道一切都源于 <tt class="docutils literal"><span class="pre">Field</span></tt> 类就行了，然后就自定义类当中关键的行为。</p>
<p>要认识到 Django 类并不是存储在 model 的属性中，这一点非常重要。类属性包含的是普通的 Python 对象，而自定义的字段类是在被它创建的时候存储在 <tt class="docutils literal"><span class="pre">Meta</span></tt> 类中的(如何做到这一点的对于本章而言并不重要)。这是因为在创建或是修改属性时，并不需要字段类。相反，字段类提供了一套机制，来完成属性值与要保存到数据库中的值(或是被序列化 <a class="reference external" href="../../topics/serialization/index.html#topics-serialization"><em>serializer</em></a> 的值)之间的互换。</p>
<p>在创建自定义字段时要注意下面几点。 你编写的 Django <tt class="docutils literal"><span class="pre">Field</span></tt> 子类提供了一套机制，以某种方式来完成 Python 实例与数据库／序列器中的值的互换（例如，保存某个值和将它用做数据筛选是不同的）。这听起来有点棘手，但是接下来的例子会解释地比较清楚。在你编写自定义字段时，只要记住你通常要创建两个类就可以了：</p>
<ul class="simple">
<li>第一个类是使用者所使用的 Python 对象。使用者会根据它的命名了解到它的使用目的，并将它分配给类的属性，比如我们例子当中的 <tt class="docutils literal"><span class="pre">Hand</span></tt> 类。</li>
<li>第二个类是 <tt class="docutils literal"><span class="pre">Field</span></tt> 的子类。它负责在永久保存形式和 Python 形式之间，对前面提到的第一个类进行转换。</li>
</ul>
</div>
</div>
<div class="section" id="s-writing-a-field-subclass">
<span id="writing-a-field-subclass"></span><h2>编写一个 field 的子类(Writing a field subclass)<a class="headerlink" href="index.html#writing-a-field-subclass" title="Permalink to this headline">¶</a></h2>
<p>在准备编写你的 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 子类时，首先要考虑的就是查找与新类相似的 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 类，看看能否可以继承某个已存在的 Django 字段，从而节省工作量。如果不能这么做，你就应该继承 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 类，它是一切行为的始祖。</p>
<p>初始化新字段的工作就是特定的参数从通用参数中分离出来，并将通用参数传递给
<tt class="xref docutils literal"><span class="pre">Field</span></tt> (就是你的父类)中的<tt class="xref docutils literal"><span class="pre">__init__()</span></tt> 方法。</p>
<p>在我们的例子中，将调用 <tt class="docutils literal"><span class="pre">HandField</span></tt> 字段。(使用 <tt class="docutils literal"><span class="pre">&lt;Something&gt;Field</span></tt> 的形式为你自定义的 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 子类命名是一个好主意，因为这样很容易就被人理解成 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 子类)。 因为没有任何类和我们的新类相似，所以我们就直接继承 <tt class="xref docutils literal"><span class="pre">Field</span></tt>：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;max_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">104</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HandField</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>我们的 <tt class="docutils literal"><span class="pre">HandField</span></tt> 接受大多数标准的字段选项(见下面的列表)，但是我们要确保它的长度固定，这是因为它需要容纳 52 张纸牌的数据，一共是104个字符。</p>
<div class="admonition note">
<p class="first admonition-title">注意</p>
<p>很多 Django 的 model 字段接受某些字段选项，而不做任何操作。例如，你可以将
<a title="django.db.models.Field.editable" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.editable"><tt class="xref docutils literal"><span class="pre">editable</span></tt></a> 和
<tt class="xref docutils literal"><span class="pre">auto_now</span></tt> 传递给一个
<a title="django.db.models.DateField" class="reference external" href="../../ref/models/fields/index.html#django.db.models.DateField"><tt class="xref docutils literal"><span class="pre">django.db.models.DateField</span></tt></a> 字段，但字段会忽略
<a title="django.db.models.Field.editable" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.editable"><tt class="xref docutils literal"><span class="pre">editable</span></tt></a> 参数
(<tt class="xref docutils literal"><span class="pre">auto_now</span></tt> 会自动设置 <tt class="docutils literal"><span class="pre">editable=False</span></tt>)。 在这个过程中不会抛出错误。</p>
<p class="last">这个行为简化了字段类，因为字段类无须再处理那些不必要的选项。它们只要将所有的选项传递给父类即可，无须再做处理。这取决于你是想让自定义字段严格地实现它所选的选项；还是想更简单点，对当前字段的行为更宽容一些。</p>
</div>
<p> <tt class="xref docutils literal"><span class="pre">__init__()</span></tt> 方法接收下面的参数：</p>
<ul class="simple">
<li><a title="django.db.models.Field.verbose_name" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.verbose_name"><tt class="xref docutils literal"><span class="pre">verbose_name</span></tt></a></li>
<li><tt class="xref docutils literal"><span class="pre">name</span></tt></li>
<li><a title="django.db.models.Field.primary_key" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.primary_key"><tt class="xref docutils literal"><span class="pre">primary_key</span></tt></a></li>
<li><tt class="xref docutils literal"><span class="pre">max_length</span></tt></li>
<li><a title="django.db.models.Field.unique" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.unique"><tt class="xref docutils literal"><span class="pre">unique</span></tt></a></li>
<li><a title="django.db.models.Field.blank" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.blank"><tt class="xref docutils literal"><span class="pre">blank</span></tt></a></li>
<li><a title="django.db.models.Field.null" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.null"><tt class="xref docutils literal"><span class="pre">null</span></tt></a></li>
<li><a title="django.db.models.Field.db_index" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.db_index"><tt class="xref docutils literal"><span class="pre">db_index</span></tt></a></li>
<li><tt class="xref docutils literal"><span class="pre">rel</span></tt>: 用于关联字段 (类似
<tt class="xref docutils literal"><span class="pre">ForeignKey</span></tt> )。仅适用于高级应用。</li>
<li><a title="django.db.models.Field.default" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.default"><tt class="xref docutils literal"><span class="pre">default</span></tt></a></li>
<li><a title="django.db.models.Field.editable" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.editable"><tt class="xref docutils literal"><span class="pre">editable</span></tt></a></li>
<li><tt class="xref docutils literal"><span class="pre">serialize</span></tt>: 如果为 <tt class="xref docutils literal"><span class="pre">False</span></tt>，当前 model 传递给 Django 的 <a class="reference external" href="../../topics/serialization/index.html#topics-serialization"><em>serializers</em></a> 时，就不会被序列化。默认为 <tt class="xref docutils literal"><span class="pre">True</span></tt>。</li>
<li><a title="django.db.models.Field.unique_for_date" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.unique_for_date"><tt class="xref docutils literal"><span class="pre">unique_for_date</span></tt></a></li>
<li><a title="django.db.models.Field.unique_for_month" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.unique_for_month"><tt class="xref docutils literal"><span class="pre">unique_for_month</span></tt></a></li>
<li><a title="django.db.models.Field.unique_for_year" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.unique_for_year"><tt class="xref docutils literal"><span class="pre">unique_for_year</span></tt></a></li>
<li><a title="django.db.models.Field.choices" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.choices"><tt class="xref docutils literal"><span class="pre">choices</span></tt></a></li>
<li><a title="django.db.models.Field.help_text" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.help_text"><tt class="xref docutils literal"><span class="pre">help_text</span></tt></a></li>
<li><a title="django.db.models.Field.db_column" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.db_column"><tt class="xref docutils literal"><span class="pre">db_column</span></tt></a></li>
<li><a title="django.db.models.Field.db_tablespace" class="reference external" href="../../ref/models/fields/index.html#django.db.models.Field.db_tablespace"><tt class="xref docutils literal"><span class="pre">db_tablespace</span></tt></a>: 目前仅适用于 Oracle 数据库和索引创建。一般来说，你可以忽略该选项。</li>
<li><tt class="xref docutils literal"><span class="pre">auto_created</span></tt>: 如果为 True ，该字段就会被自动创建，比如类实例中的 <cite>OneToOneField</cite> 字段，仅适用于高级应用。</li>
</ul>
<p>上面这些加注解的选项，在自定义字段中所起的作用和在普通字段中一样。详见 <a class="reference external" href="../../ref/models/fields/index.html#ref-models-fields"><em>field documentation</em></a> 。</p>
<div class="section" id="s-the-subfieldbase-metaclass">
<span id="the-subfieldbase-metaclass"></span><h3>SubfieldBase 元类(The <tt class="docutils literal"><span class="pre">SubfieldBase</span></tt> metaclass)<a class="headerlink" href="index.html#the-subfieldbase-metaclass" title="Permalink to this headline">¶</a></h3>
<p>我们在 <a class="reference internal" href="index.html#introduction">介绍(introduction)</a> 中提到，有两种原因使得我们需要字段子类：一是要使用自定义的数据库列类型；或是要处理复杂的 Python 类型。当然，也有可能是两者的组保。如果你只想使用自定义的数据库列类型，可以象使用从数据库中获得的标准 Python 类型一样来使用它，那么你不必读这一节。</p>
<p>如果你正在处理自定义的 Python 类型，比如我们的 <tt class="docutils literal"><span class="pre">Hand</span></tt> 类， Django 初始化我们的 model 实例并给自定义的字段属性分配一个要保存到数据库中的值，这时我们要将这个值转换成某个适用的 Python 对象。关于内部如何实现这些细节的，这有一点复杂。但是在 <tt class="docutils literal"><span class="pre">Field</span></tt> 类中要写的代码却是非溶点简单：确保你的字段子类使用了一个特别的元类(metaclass)：</p>
<dl class="class">
<dt id="django.db.models.SubfieldBase">
<!--[django.db.models.SubfieldBase]-->class <tt class="descclassname">django.db.models.</tt><tt class="descname">SubfieldBase</tt><a class="headerlink" href="index.html#django.db.models.SubfieldBase" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>例如：</p>
<div class="highlight-python"><pre>class HandField(models.Field):
    __metaclass__ = models.SubfieldBase

    def __init__(self, *args, **kwargs):
        # ...</pre>
</div>
<p>这段代码保证 <a title="to_python" class="reference internal" href="index.html#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> 方法(会在接下来提到)，会在初始化属性时被调用。</p>
</div>
<div class="section" id="s-useful-methods">
<span id="useful-methods"></span><h3>有用的方法(Useful methods)<a class="headerlink" href="index.html#useful-methods" title="Permalink to this headline">¶</a></h3>
<p>一理你创建了 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 子类并且编写了 <tt class="docutils literal"><span class="pre">__metaclass__</span></tt> 时，你可能会根据你的字段行为，考虑去重写某些标准方法。下面的方法按重要性依次递减，所以让我们从头开始介绍。</p>
<div class="section" id="s-custom-database-types">
<span id="custom-database-types"></span><h4>定制数据库类型(Custom database types)<a class="headerlink" href="index.html#custom-database-types" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="db_type">
<!--[db_type]--><tt class="descname">db_type</tt>(<em>self</em>)<a class="headerlink" href="index.html#db_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>根据 <a class="reference external" href="../../ref/settings/index.html#setting-DATABASE_ENGINE"><tt class="xref docutils literal"><span class="pre">DATABASE_ENGINE</span></tt></a> 中定义的数据库设置，返回 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 对应的数据库列类型。</p>
<p>假设你已经创建了一个 PostgreSQL 自定义类型，称为 <tt class="docutils literal"><span class="pre">mytype</span></tt>。你就可以通过继承 <tt class="docutils literal"><span class="pre">Field</span></tt> 和实现 <a title="db_type" class="reference internal" href="index.html#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> 方法，在 Django 中使用这个字段：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">MytypeField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;mytype&#39;</span>
</pre></div>
</div>
<p>一旦你有了 <tt class="docutils literal"><span class="pre">MytypeField</span></tt>，你就可以象使用其他 <tt class="docutils literal"><span class="pre">Field</span></tt> 类型一样，在 model 中使用它：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mf">80</span><span class="p">)</span>
    <span class="n">gender</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
    <span class="n">something_else</span> <span class="o">=</span> <span class="n">MytypeField</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你的目的建立一个数据库通用的应用，你就应该考虑不同数据库中列类型的差异。例如，PostgreSQL 中的日期／时间列类型被称为 <tt class="docutils literal"><span class="pre">timestamp</span></tt>，而同样的列在 MySQL 中被称为 <tt class="docutils literal"><span class="pre">datetime</span></tt> 。处理这个问题的最简单方法就是在 <tt class="docutils literal"><span class="pre">db_type()</span></tt> 方法中导入 Django 的设置模块，并检查 <a class="reference external" href="../../ref/settings/index.html#setting-DATABASE_ENGINE"><tt class="xref docutils literal"><span class="pre">DATABASE_ENGINE</span></tt></a> 设置。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyDateField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">from</span> <span class="nn">django.conf</span> <span class="k">import</span> <span class="n">settings</span>
        <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">DATABASE_ENGINE</span> <span class="o">==</span> <span class="s">&#39;mysql&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;datetime&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;timestamp&#39;</span>
</pre></div>
</div>
<p> <a title="db_type" class="reference internal" href="index.html#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> 方法仅仅被 Django 调用一次，就是在框架为你的应用生成 <tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">TABLE</span></tt> 语句的时候，这就是说，是在你第一次创建你的数据库这个时候，才会调用 db_type()。其他任何时候都不会调用这个方法，所以我们可以在它里面写一些很复杂的方法，比如上面的例子做 <a class="reference external" href="../../ref/settings/index.html#setting-DATABASE_ENGINE"><tt class="xref docutils literal"><span class="pre">DATABASE_ENGINE</span></tt></a> 检测。</p>
<p>某些数据库列类型是允许有参数的，比如 <tt class="docutils literal"><span class="pre">CHAR(25)</span></tt>， <tt class="docutils literal"><span class="pre">25</span></tt> 表示列数据最大的长度。在 model 中定义参数值要比在 <tt class="docutils literal"><span class="pre">db_type()</span></tt> 方法硬编码灵活的多。例如，做一个 <tt class="docutils literal"><span class="pre">CharMaxlength25Field</span></tt> 字段并没有多大意义：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># This is a silly example of hard-coded parameters.</span>
<span class="k">class</span> <span class="nc">CharMaxlength25Field</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;char(25)&#39;</span>

<span class="c"># In the model:</span>
<span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">my_field</span> <span class="o">=</span> <span class="n">CharMaxlength25Field</span><span class="p">()</span>
</pre></div>
</div>
<p>更好的方式是在运行时指定参数值－例如，在类实例化之时。在做到这一点，只要实现
<tt class="xref docutils literal"><span class="pre">django.db.models.Field.__init__()</span></tt> 方法即可，例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># This is a much more flexible example.</span>
<span class="k">class</span> <span class="nc">BetterCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_length</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">max_length</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BetterCharField</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;char(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span>

<span class="c"># In the model:</span>
<span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">my_field</span> <span class="o">=</span> <span class="n">BetterCharField</span><span class="p">(</span><span class="mf">25</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，如果你的列在生成时需要很复杂的 SQL ，那就在 <a title="db_type" class="reference internal" href="index.html#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> 中返回 <tt class="xref docutils literal"><span class="pre">None</span></tt> 。这会在 Django 在生成创建数据库代码时跳过这个字段。你需要以别的某种方式来创建这个字段对应的列，当然，这也告诉了你如何不使用 db_type() 这种方式来创建字段。</p>
</div>
<div class="section" id="s-converting-database-values-to-python-objects">
<span id="converting-database-values-to-python-objects"></span><h4>将数据库内容转换成 Python 对象(Converting database values to Python objects)<a class="headerlink" href="index.html#converting-database-values-to-python-objects" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="to_python">
<!--[to_python]--><tt class="descname">to_python</tt>(<em>self</em>, <em>value</em>)<a class="headerlink" href="index.html#to_python" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>将从数据库／序列器中取得的值转换成 Python 对象。</p>
<p>对于大我数应用来说，后台数据库返回格式正确的数据(比如字符串)，默认的实现只返回 <tt class="docutils literal"><span class="pre">value</span></tt>。</p>
<p>如果你的自定义 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 类要处理比字符串，时间，整数或是浮点数更复杂的数据结构，你就需要重写这个方法。做为一般规则，该方法可以优雅地处理下列参数：</p>
<ul class="simple">
<li>一个合适的类型的实例 (例如，在我们的例子中就是 <tt class="docutils literal"><span class="pre">Hand</span></tt> )。</li>
<li>一个字符串(例如，从反序列化中得到).</li>
<li>数据根据你使用的列类型所返回的一切数据。</li>
</ul>
<p>在我们的 <tt class="docutils literal"><span class="pre">HandField</span></tt> 类当中，我们将数据保存为数据库中的 VARCHAR 字段，所以我们需要在 <a title="to_python" class="reference internal" href="index.html#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> 中处理字符串和 <tt class="docutils literal"><span class="pre">Hand</span></tt> 实例：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">import</span> <span class="nn">re</span>

<span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Hand</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c"># The string case.</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;.{26}&#39;</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;..&#39;</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">p2</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">Hand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>要注意该方法总是返回一个 <tt class="docutils literal"><span class="pre">Hand</span></tt> 实例。这就是我们想保存在 model 属性中的 Python 对象。</p>
<p><strong>牢记：</strong> 如果你的自定义字段需要 <a title="to_python" class="reference internal" href="index.html#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> 方法在被创建时被调用，你应当使用早先提到的 <a class="reference internal" href="index.html#the-subfieldbase-metaclass">The SubfieldBase metaclass</a>，否则 <a title="to_python" class="reference internal" href="index.html#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> 将不会被自动调用。</p>
</div>
<div class="section" id="s-converting-python-objects-to-database-values">
<span id="converting-python-objects-to-database-values"></span><h4>将 Python 对象转换成数据库的值(Converting Python objects to database values)<a class="headerlink" href="index.html#converting-python-objects-to-database-values" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="get_db_prep_value">
<!--[get_db_prep_value]--><tt class="descname">get_db_prep_value</tt>(<em>self</em>, <em>value</em>)<a class="headerlink" href="index.html#get_db_prep_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>这是 <a title="to_python" class="reference internal" href="index.html#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> 的反方法，用来将 Python 对象转换成数据库中的值或是序列化的值。 <tt class="docutils literal"><span class="pre">value</span></tt> 参数就是当前 model 的属性值。(字段中没有包含它的 modela 引用，所以它并不能获取自己的职。)，该方法返回某种形式的数据，用来做为后台数据库查询中参数。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">get_db_prep_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">north</span><span class="p">,</span>
                <span class="n">value</span><span class="o">.</span><span class="n">east</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">south</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">west</span><span class="p">)])</span>
</pre></div>
</div>
<dl class="method">
<dt id="get_db_prep_save">
<!--[get_db_prep_save]--><tt class="descname">get_db_prep_save</tt>(<em>self</em>, <em>value</em>)<a class="headerlink" href="index.html#get_db_prep_save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>和上面的方法一样，唯一的不同是该方法只在字段值必须被保存到数据库的时候才被调用。就象它的函式名 <tt class="docutils literal"><span class="pre">get_db_prep_value</span></tt> 所反映的那样，只有当字段值在保存时所做的转换与查询时有所不同的情况下，才使用该方法。</p>
</div>
<div class="section" id="s-preprocessing-values-before-saving">
<span id="preprocessing-values-before-saving"></span><h4>存储前对字段进行预处理(Preprocessing values before saving)<a class="headerlink" href="index.html#preprocessing-values-before-saving" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="pre_save">
<!--[pre_save]--><tt class="descname">pre_save</tt>(<em>self</em>, <em>model_instance</em>, <em>add</em>)<a class="headerlink" href="index.html#pre_save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>在运行 <a title="get_db_prep_save" class="reference internal" href="index.html#get_db_prep_save"><tt class="xref docutils literal"><span class="pre">get_db_prep_save()</span></tt></a> 之前，就会调用该方法，然后从 <tt class="docutils literal"><span class="pre">model_instance</span></tt> 为该字段返回相应的属性。属性名称在 <tt class="docutils literal"><span class="pre">self.attname</span></tt> (在 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 中)。如果 model 第一次保存在数据库中， <tt class="docutils literal"><span class="pre">add</span></tt> 参数值就是 <tt class="xref docutils literal"><span class="pre">True</span></tt>，其他时候都是 <tt class="xref docutils literal"><span class="pre">False</span></tt> 。</p>
<p>如果你仅仅想在保存之存对数据库某种方式的预处理，只要重写该方法即可。例如，Django 的 <a title="django.db.models.DateTimeField" class="reference external" href="../../ref/models/fields/index.html#django.db.models.DateTimeField"><tt class="xref docutils literal"><span class="pre">DateTimeField</span></tt></a> 字段就利用该方法来正确的使用 <tt class="xref docutils literal"><span class="pre">auto_now</span></tt> 还是
<tt class="xref docutils literal"><span class="pre">auto_now_add</span></tt>。</p>
<p>如果你要重写该方法，就必须在最后返回该属性的值。如果你改动了字段值，你也应该更新字段属性。所以对该 model 的引用始终都返回正确的值。</p>
</div>
<div class="section" id="s-preparing-values-for-use-in-database-lookups">
<span id="preparing-values-for-use-in-database-lookups"></span><h4>为在数据库筛选而做准备工作(Preparing values for use in database lookups)<a class="headerlink" href="index.html#preparing-values-for-use-in-database-lookups" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="get_db_prep_lookup">
<!--[get_db_prep_lookup]--><tt class="descname">get_db_prep_lookup</tt>(<em>self</em>, <em>lookup_type</em>, <em>value</em>)<a class="headerlink" href="index.html#get_db_prep_lookup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>如果 <tt class="docutils literal"><span class="pre">value</span></tt> 要在数据库筛选条件中使用 ( SQL 中的 <tt class="docutils literal"><span class="pre">WHERE</span></tt> 从句)，就要提前进行准备工作。 <tt class="docutils literal"><span class="pre">lookup_type</span></tt> 得是可用的 Django 过滤器的筛选条件之一： <tt class="docutils literal"><span class="pre">exact</span></tt>, <tt class="docutils literal"><span class="pre">iexact</span></tt>, <tt class="docutils literal"><span class="pre">contains</span></tt>, <tt class="docutils literal"><span class="pre">icontains</span></tt>,
<tt class="docutils literal"><span class="pre">gt</span></tt>, <tt class="docutils literal"><span class="pre">gte</span></tt>, <tt class="docutils literal"><span class="pre">lt</span></tt>, <tt class="docutils literal"><span class="pre">lte</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">startswith</span></tt>, <tt class="docutils literal"><span class="pre">istartswith</span></tt>,
<tt class="docutils literal"><span class="pre">endswith</span></tt>, <tt class="docutils literal"><span class="pre">iendswith</span></tt>, <tt class="docutils literal"><span class="pre">range</span></tt>, <tt class="docutils literal"><span class="pre">year</span></tt>, <tt class="docutils literal"><span class="pre">month</span></tt>, <tt class="docutils literal"><span class="pre">day</span></tt>,
<tt class="docutils literal"><span class="pre">isnull</span></tt>, <tt class="docutils literal"><span class="pre">search</span></tt>, <tt class="docutils literal"><span class="pre">regex</span></tt>, 和 <tt class="docutils literal"><span class="pre">iregex</span></tt>.</p>
<p>你的方法必须要为处理这些 <tt class="docutils literal"><span class="pre">lookup_type</span></tt> 值而做好准备，而且如果 <tt class="docutils literal"><span class="pre">value</span></tt>  是一个错误的类型(比如应该是一个对象，却用了一个列表)，那就要抛出 <tt class="docutils literal"><span class="pre">ValueError</span></tt> 异常；或者该字段并不支持这种查询类型，就会抛出 <tt class="docutils literal"><span class="pre">TypeError</span></tt> 导常。对很多字段来说，你可以单独处理那些特殊的筛选条件，而将其他的交给父类的 <a title="get_db_prep_lookup" class="reference internal" href="index.html#get_db_prep_lookup"><tt class="xref docutils literal"><span class="pre">get_db_prep_lookup()</span></tt></a> 方来来处理。</p>
<p>如果你要实现 <tt class="docutils literal"><span class="pre">get_db_prep_save()</span></tt>，通常你要先实现 <tt class="docutils literal"><span class="pre">get_db_prep_lookup()</span></tt>。 如果你不这么做， <tt class="docutils literal"><span class="pre">get_db_prep_value</span></tt> 就会调用默认地实现来管理 <tt class="docutils literal"><span class="pre">exact</span></tt>, <tt class="docutils literal"><span class="pre">gt</span></tt>, <tt class="docutils literal"><span class="pre">gte</span></tt>,
<tt class="docutils literal"><span class="pre">lt</span></tt>, <tt class="docutils literal"><span class="pre">lte</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt> 和 <tt class="docutils literal"><span class="pre">range</span></tt> 筛选条件。</p>
<p>你也会想实现该方法来限制在自定义字段类型中所用到的筛选条件。</p>
<p>要注意，对 <tt class="docutils literal"><span class="pre">range</span></tt> 和 <tt class="docutils literal"><span class="pre">in</span></tt> 筛选而言， <tt class="docutils literal"><span class="pre">get_db_prep_lookup</span></tt> 将接收一个对象列表(可能是正确的类型) 并且需要将他们转换成适应数据库的列表。大多数情况下，你可以重用 <tt class="docutils literal"><span class="pre">get_db_prep_value()</span></tt>，或是至少重用一部分。</p>
<p>例如，下面的代码实现了 <tt class="docutils literal"><span class="pre">get_db_prep_lookup</span></tt> 来限制两种条件，而只使用 <tt class="docutils literal"><span class="pre">exact</span></tt> 和 <tt class="docutils literal"><span class="pre">in</span></tt> :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">get_db_prep_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lookup_type</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># We only handle &#39;exact&#39; and &#39;in&#39;. All others are errors.</span>
        <span class="k">if</span> <span class="n">lookup_type</span> <span class="o">==</span> <span class="s">&#39;exact&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_db_prep_value</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">lookup_type</span> <span class="o">==</span> <span class="s">&#39;in&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_db_prep_value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Lookup type </span><span class="si">%r</span><span class="s"> not supported.&#39;</span> <span class="o">%</span> <span class="n">lookup_type</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-specifying-the-form-field-for-a-model-field">
<span id="specifying-the-form-field-for-a-model-field"></span><h4>为 model 字段指定表单字段(Specifying the form field for a model field)<a class="headerlink" href="index.html#specifying-the-form-field-for-a-model-field" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="formfield">
<!--[formfield]--><tt class="descname">formfield</tt>(<em>self</em>, <em>form_class=forms.CharField</em>, <em>**kwargs</em>)<a class="headerlink" href="index.html#formfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>在某字段在 model 中显示时，该方法返回字段默认的表单字段。我们通过 <tt class="xref docutils literal"><span class="pre">ModelForm</span></tt> 调用该方法。</p>
<p>所有的 <tt class="docutils literal"><span class="pre">kwargs</span></tt> 字典被直接传递给表单字段的 <tt class="xref docutils literal"><span class="pre">Field__init__()</span></tt> 方法。正常情况下，你所要做就是为 <tt class="docutils literal"><span class="pre">form_class</span></tt> 参数设置一个默认值，然后进一步委托给父类来处理。这可能要求你编写一个自定义字段(甚至可能是一个部件 widget)。 详见 <a class="reference external" href="../../topics/forms/index.html#topics-forms-index"><em>表单文档(forms documentation)</em></a> ，再参考一下
<a title="A collection of various Django snippets that are useful only for a particular country or culture." class="reference external" href="../../ref/contrib/localflavor/index.html#module-django.contrib.localflavor"><tt class="xref docutils literal"><span class="pre">django.contrib.localflavor</span></tt></a> 中展示自定义部件的代码。</p>
<p>继续回到我们的例子中，我们可以编写一个 <a title="formfield" class="reference internal" href="index.html#formfield"><tt class="xref docutils literal"><span class="pre">formfield()</span></tt></a> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">formfield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># This is a fairly standard way to set up some defaults</span>
        <span class="c"># while letting the caller override them.</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;form_class&#39;</span><span class="p">:</span> <span class="n">MyFormField</span><span class="p">}</span>
        <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">HandField</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">formfield</span><span class="p">(</span><span class="o">**</span><span class="n">defaults</span><span class="p">)</span>
</pre></div>
</div>
<p>这段代码假设我们已引入了一个 <tt class="docutils literal"><span class="pre">MyFormField</span></tt> 字段类 (它有默认的部件)。 这个文档并不涉及编写编写<b>自定义表单字段</b>的细节。</p>
</div>
<div class="section" id="s-emulating-built-in-field-types">
<span id="emulating-built-in-field-types"></span><h4>模仿内置的字段类型(Emulating built-in field types)<a class="headerlink" href="index.html#emulating-built-in-field-types" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="get_internal_type">
<!--[get_internal_type]--><tt class="descname">get_internal_type</tt>(<em>self</em>)<a class="headerlink" href="index.html#get_internal_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>根据给定的在数据库级别的模仿的 <tt class="xref docutils literal"><span class="pre">Field</span></tt> 子类的名称，而得到一个字符串。该方法用来确定简单情况下的数据库列类型。</p>
<p>如果你已经创建了一个 <a title="db_type" class="reference internal" href="index.html#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> 方法，那你就不必担心 <a title="get_internal_type" class="reference internal" href="index.html#get_internal_type"><tt class="xref docutils literal"><span class="pre">get_internal_type()</span></tt></a> -- 它不会被使用了。但是有时，你所需的数据库存储的类型与其他字段相似，所以你要使用其他字段的逻辑来创建正确的列。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">get_internal_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;CharField&#39;</span>
</pre></div>
</div>
<p>无论我们使用何种数据库后台，都是使用 <tt class="docutils literal"><span class="pre">syncdb</span></tt> 和其他 SQL 命令为保存字符来创建正确的字段的。</p>
<p>针对你所用的数据库后台，如果 <a title="get_internal_type" class="reference internal" href="index.html#get_internal_type"><tt class="xref docutils literal"><span class="pre">get_internal_type()</span></tt></a> 返回了一个 Djanog 不知如何确认存储类型的字符串 -- 也就是说，它并没有出现在 <tt class="docutils literal"><span class="pre">django.db.backends.&lt;db_name&gt;.creation.DATA_TYPES</span></tt> 中 -- 那么这么字符串仍会被序列器所用，但默认的 <a title="db_type" class="reference internal" href="index.html#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> 方法将返回 <tt class="xref docutils literal"><span class="pre">None</span></tt>。 详见 <a title="db_type" class="reference internal" href="index.html#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> ，了解为什么这么做的原因。将一个描述性的字符发给序列化器做为字段的类型，是一个很好的主意。这样不仅仅是在 Django 中，也可以在其他地方使用序列化器。</p>
</div>
<div class="section" id="s-converting-field-data-for-serialization">
<span id="converting-field-data-for-serialization"></span><h4>对字段数据进行序列化(Converting field data for serialization)<a class="headerlink" href="index.html#converting-field-data-for-serialization" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="value_to_string">
<!--[value_to_string]--><tt class="descname">value_to_string</tt>(<em>self</em>, <em>obj</em>)<a class="headerlink" href="index.html#value_to_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>由序列化器使用该方法将字段值转换成用出输出的字符串。调用 <tt class="xref docutils literal"><span class="pre">Field._get_val_from_obj(obj)()</span></tt> 是得到序例化值的最佳方法。例如，因为我们的 <tt class="docutils literal"><span class="pre">HandField</span></tt> 使用了字符串来存储数据，所以我们可以重用已有的转换代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">value_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_val_from_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_db_prep_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-some-general-advice">
<span id="some-general-advice"></span><h3>一些常用的意建(Some general advice)<a class="headerlink" href="index.html#some-general-advice" title="Permalink to this headline">¶</a></h3>
<p>编写自定义字段并不是一个很简单的事情，特别是在你需要在 Python 类型和数据库以及序列化格式进行转换的情况下。以下有两点意建会让这个过程变得顺利一些：</p>
<ol class="arabic simple">
<li>查看已有的 Django fields (在<tt class="docutils literal"><span class="pre">django/db/models/fields/__init__.py</span></tt>) 找找灵感。尽量找一个与你想要的字段非常类似，但是略有不同字段，而避免完全从头开始写一个全新的字段。</li>
<li>在你要包装成字段的类当中，添加 <tt class="xref docutils literal"><span class="pre">__str__()</span></tt> 或 <tt class="xref docutils literal"><span class="pre">__unicode__()</span></tt> 方法。字段代码中有很多默认行为要对字段值使用用 <tt class="xref docutils literal"><span class="pre">force_unicode()</span></tt> 方法。(在我们的例子中， <tt class="docutils literal"><span class="pre">value</span></tt> 就是一个 <tt class="docutils literal"><span class="pre">Hand</span></tt> 实例，而不是一个 <tt class="docutils literal"><span class="pre">HandField</span></tt>)。所以如果你用 <tt class="xref docutils literal"><span class="pre">__unicode__()</span></tt> 方法自动将 Python 对象转换为字符串，那么就会节省很多工作。</li>
</ol>
</div>
</div>
<div class="section" id="s-writing-a-filefield-subclass">
<span id="writing-a-filefield-subclass"></span><h2>编写文件字段子类(Writing a <tt class="docutils literal"><span class="pre">FileField</span></tt> subclass)<a class="headerlink" href="index.html#writing-a-filefield-subclass" title="Permalink to this headline">¶</a></h2>
<p>做为上述方法的补充，用来处理文件的字段与其他字段有所不同，有一些必须考虑到的特殊要求。<tt class="docutils literal"><span class="pre">FileField</span></tt> 提供了大多数机制，比如，控制数据库存储和读取，这些机制可以保持不变，而让子类去处理支持特殊文件类型的需求。</p>
<p>Django 提供了 <tt class="docutils literal"><span class="pre">File</span></tt> 类，它做为一个访问文件和进行文件操作的代理使用。它可以被继承，从而自定义子类如何访问文件，也定义了哪些方法在子类中可用。它的代码在 <tt class="docutils literal"><span class="pre">django.db.models.fields.files</span></tt>，关于该字段默认的行为在 <a class="reference external" href="../../ref/files/file/index.html#ref-files-file"><em>文件操作文档(file documentation)</em></a>有详细介绍。</p>
<p>一旦继承 <tt class="docutils literal"><span class="pre">File</span></tt> 的子类被创建，新的 <tt class="docutils literal"><span class="pre">FileField</span></tt> 子类必须得使用父类。要做到这一点，简单将新的 <tt class="docutils literal"><span class="pre">File</span></tt> 子类分配给  <tt class="docutils literal"><span class="pre">FileField</span></tt> 子类的 <tt class="docutils literal"><span class="pre">attr_class</span></tt> 属性即可。</p>
<div class="section" id="s-a-few-suggestions">
<span id="a-few-suggestions"></span><h3>一些建议(A few suggestions)<a class="headerlink" href="index.html#a-few-suggestions" title="Permalink to this headline">¶</a></h3>
<p>除了上述内容，这还有一些建议，可以大大提高编写代码的效率，改善代码的可读性。</p>
<ol class="arabic simple">
<li> Django 自带的 <tt class="docutils literal"><span class="pre">ImageField</span></tt> (
<tt class="docutils literal"><span class="pre">django/db/models/fields/files.py</span></tt>) 是一个学习如何继承 <tt class="docutils literal"><span class="pre">FileField</span></tt> 来支持某个特殊文件类型的极好例子，因为它包含了我们上面提到的所有技术。</li>
<li>尽可能的缓存文件属性，这是因为文件一般是存储在远程文件系统中的，检索他们要花费不少的时间，甚至是金钱，而这些代价并不是必要的。一旦检索某个文件来获得文件内容的某些数据，就尽可能的缓存数据，从而减少其后再次获取数据时的检索文件的次数。</li>
</ol>
</div>
</div>
</div>



<div id="content-secondary">
  <h2 id="comments">Questions/Feedback</h2>
  <p>Having trouble? We'd like to help!</p>
  <ul>
    <li>
      Try the <a href="../../faq/index.html">FAQ</a> — it's got answers to many common
      questions.
    </li>
    <li>
      Search for information in the <a
      href="http://groups.google.com/group/django-users/">archives of the
      django-users mailing list</a>, or <a
      href="http://groups.google.com/group/django-users/">post a question</a>.
    </li>
    <li>
      Ask a question in the <a href="irc://irc.freenode.net/">#django IRC
      channel</a>, or search the <a href="http://oebfare.com/logger/django/">IRC
      logs</a> to see if its been asked before.
    </li>
    <li>
      If you notice errors with this documentation, please <a
      href="http://code.djangoproject.com/simpleticket?component=Documentation">
      open a ticket</a> and let us know! Please only use the ticket tracker for
      criticisms and improvements on the docs. For tech support, use the
      resources above.
    </li>
  </ul>
</div>

		</div>
		<!-- END #content-main -->
		<div id="content-related" class="sidebar">
		
  
    <h2>Contents</h2>
    
      <ul>
<li><a class="reference external" href="index.html">Writing custom model fields</a><ul>
<li><a class="reference external" href="index.html#introduction">Introduction</a><ul>
<li><a class="reference external" href="index.html#our-example-object">Our example object</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#background-theory">Background theory</a><ul>
<li><a class="reference external" href="index.html#database-storage">Database storage</a></li>
<li><a class="reference external" href="index.html#what-does-a-field-class-do">What does a field class do?</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#writing-a-field-subclass">Writing a field subclass</a><ul>
<li><a class="reference external" href="index.html#the-subfieldbase-metaclass">The <tt class="docutils literal"><span class="pre">SubfieldBase</span></tt> metaclass</a></li>
<li><a class="reference external" href="index.html#useful-methods">Useful methods</a><ul>
<li><a class="reference external" href="index.html#custom-database-types">Custom database types</a></li>
<li><a class="reference external" href="index.html#converting-database-values-to-python-objects">Converting database values to Python objects</a></li>
<li><a class="reference external" href="index.html#converting-python-objects-to-database-values">Converting Python objects to database values</a></li>
<li><a class="reference external" href="index.html#preprocessing-values-before-saving">Preprocessing values before saving</a></li>
<li><a class="reference external" href="index.html#preparing-values-for-use-in-database-lookups">Preparing values for use in database lookups</a></li>
<li><a class="reference external" href="index.html#specifying-the-form-field-for-a-model-field">Specifying the form field for a model field</a></li>
<li><a class="reference external" href="index.html#emulating-built-in-field-types">Emulating built-in field types</a></li>
<li><a class="reference external" href="index.html#converting-field-data-for-serialization">Converting field data for serialization</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#some-general-advice">Some general advice</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#writing-a-filefield-subclass">Writing a <tt class="docutils literal"><span class="pre">FileField</span></tt> subclass</a><ul>
<li><a class="reference external" href="index.html#a-few-suggestions">A few suggestions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    
  
  
  
    <h2>Search</h2>
    
    <form action="../../search/index.html" id="search" class="search">
  <div>
    <input type="hidden" name="cx" value="009763561546736975936:e88ek0eurf4" />
    <input type="hidden" name="cof" value="FORID:11" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="hidden" name="hl" value="" />
    <input id="id_search_q" type="text" class="query" name="q" />
    <input type="submit" name="sa" class="submit" value="Search" />
    <ul>
<li><label for="id_search_as_q_0"><input checked="checked" type="radio" id="id_search_as_q_0" value="more:dev_docs" name="as_q" /> Latest</label></li>
<li><label for="id_search_as_q_1"><input type="radio" id="id_search_as_q_1" value="more:1.0_docs" name="as_q" /> 1.0</label></li>
<li><label for="id_search_as_q_2"><input type="radio" id="id_search_as_q_2" value="more:0.96_docs" name="as_q" /> 0.96</label></li>
<li><label for="id_search_as_q_3"><input type="radio" id="id_search_as_q_3" value="more:all_docs" name="as_q" /> All</label></li>
</ul>
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=search&amp;lang="></script>
  
  
  
    <h2>Browse</h2>
    <ul>
      
        
          <li>Prev: <a href="../custom-management-commands/index.html">Writing custom django-admin commands</a></li>
        
        
          <li>Next: <a href="../custom-template-tags/index.html">Custom template tags and filters</a></li>
        
        <li><a href="../../contents/index.html">Table of contents</a></li>
        
          <li><a href="../../genindex/index.html">General Index</a></li>
        
          <li><a href="../../modindex/index.html">Global Module Index</a></li>
        
      
    </ul>
  
  
  
    <h2>You are here:</h2>
    <ul>
      
        <li>
          <a href="../../index.html">Django dev documentation</a>
          
            <ul><li><a href="../index.html">&#8220;How-to&#8221; guides</a>
          
          <ul><li>Writing custom model fields</li></ul>
          </li></ul>
        </li>
      
    </ul>
  
  
  
    <h3>Last update:</h3>
    <div>November 19, 2009, 4 p.m. (<a href="http://www.timeanddate.com/worldclock/city.html?n=64">CDT</a>)</div>
  

		</div>
		<!-- END #content-related -->

		</div>
		<!-- END #content -->
		<div id="footer">
			<p>&copy; 2005-2009 <a href="http://www.djangoproject.com/foundation/">Django Software Foundation</a> unless otherwise noted. Django is a registered trademark of the Django Software Foundation. 
			Hosting graciously provided by <a href="http://mediatemple.net/">
			<img style="vertical-align: middle; position: relative; top: -1px;" src="http://media.djangoproject.com/img/site/mt.png" alt="media temple" /></a>
			</p>
		</div>
		<!-- END #footer -->
	</div>
	<!-- END #container -->
	</body>
</html>

